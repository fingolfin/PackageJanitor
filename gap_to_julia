#!/bin/bash

GAP_PKG_DIR=~/.gap/pkg/
JULIA_PKG_DIR=~/.julia/dev/

if [ "$#" -ne 1 ]; then
	echo "Usage: gap_to_julia PKG_NAME"
	exit 1
fi

PKG_NAME="$1"

if [ -d "$GAP_PKG_DIR$PKG_NAME" ]; then
	PKG_FULL_NAME="$PKG_NAME"
elif [ -d "$GAP_PKG_DIR/CAP_project/$PKG_NAME" ]; then
	PKG_FULL_NAME="CAP_project/$PKG_NAME"
elif [ -d "$GAP_PKG_DIR/CategoricalTowers/$PKG_NAME" ]; then
	PKG_FULL_NAME="CategoricalTowers/$PKG_NAME"
else
	echo "Could not find GAP package $PKG_NAME"
	exit 1
fi

if [ ! -d "$JULIA_PKG_DIR$PKG_NAME" ]; then
	echo "Could not find Julia package $PKG_NAME"
	exit 1
fi

mkdir -p "$JULIA_PKG_DIR$PKG_NAME/src/gap/"
mkdir -p "$JULIA_PKG_DIR$PKG_NAME/docs/src/"

if [ -d "$GAP_PKG_DIR$PKG_FULL_NAME/gap/precompiled_categories/" ]; then
	mkdir -p "$JULIA_PKG_DIR$PKG_NAME/src/gap/precompiled_categories/"
fi

cp -u "$(dirname $(realpath $0))/init.jl" "$JULIA_PKG_DIR$PKG_NAME/src/init.jl"
cmp -s "$(dirname $(realpath $0))/init.jl" "$JULIA_PKG_DIR$PKG_NAME/src/init.jl" || echo "init.jl in Julia package was modified, not overwriting"

cd "$GAP_PKG_DIR$PKG_FULL_NAME"

cat "init.g" | sed "s/ReadPackage( \"$PKG_NAME\", /include( /g" | sed 's/" );$/.autogen.jl" );/' > "$JULIA_PKG_DIR$PKG_NAME/src/init.g.autogen.jl"
cat "read.g" | sed "s/ReadPackage( \"$PKG_NAME\", /include( /g" | sed 's/" );$/.autogen.jl" );/' > "$JULIA_PKG_DIR$PKG_NAME/src/read.g.autogen.jl"

cd gap

chmod u+w "$JULIA_PKG_DIR$PKG_NAME"/src/gap/*.autogen.jl

syntax_replacements() {
	sed 's/ = / == /g' \
	| sed 's/ <> / != /g' \
	| sed 's/ :=/ =/g' \
	| sed 's/ : /; /g' \
	| sed 's/ :$/,/g' \
	| sed 's/!\././g' \
	| sed 's/ then$//g' \
	| sed 's/fi;$/end;/g' \
	| sed 's/ do$//g' \
	| sed 's/od;$/end;/g' \
	| sed 's/ and / \&\& /g' \
	| sed 's/ and$/ \&\&/g' \
	| sed 's/ or / || /g' \
	| sed 's/ or$/ ||/g' \
	| sed 's/not /!/g' \
	| sed 's/elif/elseif/g' \
	| sed 's/\.( \([^)]*\) )/[\1]/g' \
	| sed 's/\.(\([^)]*\))/[\1]/g' \
	| sed 's/infinity/Inf/g' \
	| sed 's/\[ \([^].[]*\) \.\. \([^][]*\) \]/(\1):(\2)/g' `# [ a .. b ] -> (a):(b) where a and b do not contain square brackets` \
	| sed 's/\[ \([^].[]*\) \.\. \([^][]*\)\[\([^].[]*\)\]\([^][]*\) \]/(\1):(\2[\3]\4)/g' `# [ a .. b ] -> (a):(b) where b contains a pair of square brackets` \
	| sed 's/Unbind( \(.*\) );$/\1 = nothing;/g' \
	| sed 's/{ arg } ->/( arg... ) ->/g' \
	| sed 's/{\([^}]*\)} ->/(\1) ->/g' \
	| sed 's/{/[/g' \
	| sed 's/}/]/g' \
	| sed 's/ in / ⥉ /g' `# we want "in" to bind stronger than "!"` \
	| sed 's/for \([^⥉]*\) ⥉ \([^⥉]*\)$/for \1 in \2/g' \
	| sed 's/function( arg )/function( arg... )/g' \
	| sed 's/function ( arg )/function ( arg... )/g' \
	| sed 's/Method( \\\[\\\],/Method( getindex,/g' \
	| sed 's/Method( \\=,/Method( ==,/g' \
	| sed 's/Method( \\+,/Method( +,/g' \
	| sed 's/Method( \\-,/Method( -,/g' \
	| sed 's/Method( \\\*,/Method( *,/g' \
	| sed 's/Method( \\\/,/Method( \/,/g' \
	| sed 's/Method( \\in,/Method( in,/g' \
	| sed 's/^DeclareInfoClass(/@DeclareInfoClass(/g' \
	| sed 's/^DeclareAttribute(/@DeclareAttribute(/g' \
	| sed 's/^DeclareSynonymAttr(/@DeclareSynonymAttr(/g' \
	| sed 's/^DeclareProperty(/@DeclareProperty(/g' \
	| sed 's/^DeclareFilter(/@DeclareFilter(/g' \
	| sed 's/^DeclareCategory(/@DeclareFilter(/g' \
	| sed 's/^InstallValue(/@InstallValueConst(/g' \
	| sed 's/InstallValue(/@InstallValue(/g' \
	| sed 's/BindGlobal(/@BindGlobal(/g' \
	| sed 's/DeclareGlobalFunction(/@DeclareGlobalFunction(/g' \
	| sed 's/InstallGlobalFunction(/@InstallGlobalFunction(/g' \
	| sed 's/^DeclareOperation(/@DeclareOperation(/g' \
	| sed 's/^DeclareOperationWithCache(/@DeclareOperation(/g' \
	| sed 's/^KeyDependentOperation(/@KeyDependentOperation(/g' \
	| sed 's/^InstallMethod(/InstallMethod( @__MODULE__, /g' \
	| sed 's/^InstallOtherMethod(/InstallMethod( @__MODULE__, /g' \
	| sed 's/^InstallMethodForCompilerForCAP(/InstallMethod( @__MODULE__, /g' \
	| sed 's/^InstallOtherMethodForCompilerForCAP(/InstallMethod( @__MODULE__, /g' \
	| sed 's/\bAssert\b/@Assert/g' \
	| sed 's/\bNTuple\b/NTupleGAP/g' \
	| sed 's/\bPair\b/PairGAP/g' \
	| sed 's/\bUnion\b/UnionGAP/g' \
	| sed 's/\bInt\b/IntGAP/g' \
	| sed 's/\bString\b/StringGAP/g' \
	| sed 's/\bSet\b/SetGAP/g'
}
export -f syntax_replacements

test_replacements() {
	if [ "$1" = "CAP" ]; then
		USING="using MonoidalCategories; using $1"
	elif [ "$1" = "MonoidalCategories" ]; then
		USING="using CAP; using $1"
	elif [ "$1" = "CartesianCategories" ]; then
		USING="using CAP; using $1"
	elif [ "$1" = "Toposes" ]; then
		USING="using CAP; using CartesianCategories; using FinSetsForCAP; using $1"
	elif [ "$1" = "FinSetsForCAP" ]; then
		USING="using CAP; using CartesianCategories; using Toposes; using $1"
	else
		echo "Unkown package $1, please explicitly add its dependencies"
		USING="using CAP; using $1"
	fi
	# revert printing of ranges, hack: repeat this for multiple ranges occuring in the same line
	sed 's/^\([^>g].*\)(\([0-9]*\)):(\([0-9]*\))/\1[ \2 .. \3 ]/g' \
	| sed 's/^\([^>g].*\)(\([0-9]*\)):(\([0-9]*\))/\1[ \2 .. \3 ]/g' \
	| sed 's/^\([^>g].*\)(\([0-9]*\)):(\([0-9]*\))/\1[ \2 .. \3 ]/g' \
	| sed 's/^\([^>g].*\)(\([0-9]*\)):(\([0-9]*\))/\1[ \2 .. \3 ]/g' \
	| sed 's/^\([^>g].*\)(\([0-9]*\)):(\([0-9]*\))/\1[ \2 .. \3 ]/g' \
	| sed 's/^gap> /julia> /g' \
	| sed 's/^> /        /g' \
	| sed 's/;$//g' \
	| sed 's/julia> LoadPackage( .*/julia> true/g' \
	| sed '/^#/d' \
	| sed 's/julia> /\njulia> /g' \
	| sed "s/julia> START_TEST(.*/\`\`\`jldoctest\njulia> $USING/g" \
	| sed 's/julia> STOP_TEST(.*/\`\`\`/g' \
	`# revert some code changes also affecting output lines` \
	| sed 's/^<A[n ].*object ⥉ /<An object in /g' \
	| sed 's/^A[n ].*object ⥉ /An object in /g' \
	| sed 's/^<A[n ].*morphism ⥉ /<A morphism in /g' \
	| sed 's/^A[n ].*morphism ⥉ /A morphism in /g' \
	| sed 's/^(\([0-9]*\)):(\([0-9]*\))$/[ \1 .. \2 ]/g'
}
export -f test_replacements

find . \( -type d -name .git -prune \) -o \( -type f -name '*.g[di]' \) -exec bash -c "cat '{}' | syntax_replacements > $JULIA_PKG_DIR$PKG_NAME/src/gap/'{}'.autogen.jl" \;

chmod a-w "$JULIA_PKG_DIR$PKG_NAME"/src/gap/*.autogen.jl

cd ../tst

chmod u+w "$JULIA_PKG_DIR$PKG_NAME"/docs/src/*.autogen.md

# use perl to handle line continuation and empty lines starting comments
find . \( -type d -name .git -prune \) -o \( -type f -name '*.tst' \) -exec bash -c "cat '{}' | perl -p -e 's/\\\\\\n//' | perl -0 -p -e 's/\\n\\n#.*\\n/\\n/g' | syntax_replacements | test_replacements $PKG_NAME > $JULIA_PKG_DIR$PKG_NAME/docs/src/'{}'.autogen.md" \;

rm $JULIA_PKG_DIR$PKG_NAME/docs/src/100_LoadPackage.tst.autogen.md

if [ "$PKG_NAME" = "CAP" ]; then
	# ReadPackage
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap10.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap11.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap21.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap22.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap23.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap24.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap25.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap26.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap27.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap28.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap29.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap30.tst.autogen.md

	# HomalgFieldOfRationals
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap12.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap13.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap14.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap15.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap16.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap17.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap18.tst.autogen.md

	# Functor example (continued)
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap02.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap03.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap04.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap05.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap06.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap07.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cap08.tst.autogen.md

	# needs CapCat
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/CAP_INTERNAL_ASSERT_VALUE_IS_OF_TYPE_GETTER.tst.autogen.md
fi

if [ "$PKG_NAME" = "FinSetsForCAP" ]; then
	# problems with world age
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/CartesianClosedOpposite.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/SkeletalCartesianClosedOpposite.tst.autogen.md
	
	# lists with holes
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap01.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap03.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap05.tst.autogen.md
	
	# CompilerForCAP
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap58.tst.autogen.md
	
	# continuation
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap26.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap28.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap48.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap49.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/finsetsforcap57.tst.autogen.md
fi

if [ "$PKG_NAME" = "MonoidalCategories" ]; then
	# needs GaussForHomalg
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/monoidalcategories01.tst.autogen.md
	
	# needs CommutativeRingOfLinearCategoryOperation
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/TerminalCategoryMonoidal.tst.autogen.md
fi

if [ "$PKG_NAME" = "CartesianCategories" ]; then
	# needs implication `InstallTrueMethod( IsBicartesianClosedCategory, IsCartesianClosedCategory and IsCocartesianCategory )`
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/cartesiancategories01.tst.autogen.md
	
	# needs CommutativeRingOfLinearCategoryOperation
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/TerminalCategoryCartesian.tst.autogen.md
	
	# problems with world age
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/TerminalCategoryCocartesian.tst.autogen.md
fi

if [ "$PKG_NAME" = "Toposes" ]; then
	# continuation
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/toposes03.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/toposes05.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/toposes07.tst.autogen.md
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/toposes08.tst.autogen.md
	
	# needs implication `InstallTrueMethod( IsBicartesianClosedCategory, IsCartesianClosedCategory and IsCocartesianCategory )`
	rm $JULIA_PKG_DIR$PKG_NAME/docs/src/toposes09.tst.autogen.md
fi

chmod a-w "$JULIA_PKG_DIR$PKG_NAME"/docs/src/*.autogen.md
